#!/usr/bin/env python3
"""
Main function for automated printer movement sequence
Connects, homes, and moves through specified coordinates
"""

import sys
import time
import csv
import os
from datetime import datetime
from klipper_controller import KlipperController
#from utills.loadcell import getLoad, initialize_loadcell
from camera_integration import *
from g_code_comands import *
from data_collection import DataCollector
import tkinter as tk
from Camera_gui import CameraGUI
from configs import *
import threading

# Global variable for print sequence control
print_sequence_started = False

"""
Steps:

1. Initialize the printer controller
2. Initialize the ballance and loadcell
3. Initialize the cameras
3. Reset Nozzle Offset Variable
4. Load the ToolPath For the Printer
5. Home the printer
6. Begin Recording Data
8. * Printer Operations *


"""

"""
data:

- create folder for each print with timestamp as name
- save toolpath to folder
-save data to folder
-save camera images to folder

"""

"""
- In toolpath save tooplath as a txt file
- Break down linear print commands into 1mm steps
- Add Camera Move Idicators Example: ;CAPTURE: camera_id, X, Y, Z


- for pressure passed extrussion 
    - if printing measure the pressure based on the loadcell reading
    - feed to the pressure controller
    - Given current extrussion seed and pressure passed through, determin new extrussion seed
    - given extrussion speed determin E value and apend it to the current g code command
    -  send the g code command to the printer


"""


def generate_toolpath(prnt, cap):
    toolpath = []

    toolpath.extend(home())
    toolpath.extend(printPrimeLine(xStart=5, yStart=10, len=10, prnt=prnt))
    toolpath.extend(printPrimeLine(xStart=10, yStart=10, len=10, prnt=prnt))
    toolpath.extend(printPrimeLine(xStart=15, yStart=10, len=10, prnt=prnt))
    # Tool Path Generation
    toolpath = []

    # Spape Fidelity Test
    toolpath.extend(lattice(start_x=10, start_y=40, rows=5, cols=5, spacing=3, prnt=prnt))
    toolpath.extend(capture_print(camera=1, x=17.5, y=0, z=60, prnt=prnt))
    toolpath.extend(contracting_square_wave(start_x=40, start_y=40, height=40, width=5, iterations=5, shrink_rate=0.95, prnt=prnt))
    toolpath.extend(capture_print(camera=1, x=7.5, y=17.5, z=0, prnt=prnt))


    # Striaght Line Test
    toolpath.extend(straight_line(40, 90, 40, 5, 5, prnt))
    toolpath.extend(capture_print(camera=1, x=7.5, y=17.5, z=0, prnt=prnt))
    return toolpath

def data_directory():
    """
    Create a timestamped directory within the data folder.
    Returns the folder name in format MonthMM_DD_HH_MM_SS
    """
    
    
    # Create data folder if it doesn't exist
    data_folder = "data"
    if not os.path.exists(data_folder):
        os.makedirs(data_folder)
    
    # Generate timestamp in the required format
    timestamp = datetime.now().strftime("%m_%d_%H_%M_%S")
    
    # Create the full path for the new directory
    new_dir_path = os.path.join(data_folder, timestamp)
    
    # Create the directory
    os.makedirs(new_dir_path, exist_ok=True)
    
    print(f"Created timestamped directory: {new_dir_path}")
    return timestamp

def save_toolpath(toolpath, data_folder):
        """
        Save the toolpath as a G-code file
        """
        # Generate timestamp for filename
        timestamp = datetime.now().strftime("%m_%d_%H_%M_%S")
        filename = f"toolpath_{timestamp}.gcode"
        filepath = os.path.join(data_folder, filename)
        
        try:
            with open(filepath, 'w') as f:
                # Write G-code header
                f.write("; Toolpath generated by MXene printer\n")
                f.write(f"; Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write("; Format: G1 X<x> Y<y> Z<z> E<extrusion>\n\n")
                
                # Write each toolpath point as G-code
                for i, point in enumerate(toolpath):
                    x, y, z, e = point
                    f.write(f"G1 X{x:.3f} Y{y:.3f} Z{z:.3f} E{e:.3f}\n")
                
                f.write("\n; End of toolpath\n")
            
            print(f"✓ Toolpath saved as G-code: {filepath}")
            return filepath
            
        except Exception as e:
            print(f"✗ Error saving toolpath: {e}")
            return None

            
def capture_live_print(camera_id, x, y, z, time_lapse=False, time_lapse_interval=30, time_lapse_duration=1800, data_folder=None):
    """
    Capture live print images with optional timelapse functionality
    
    Args:
        camera_id: Camera ID to capture from
        x, y, z: Current position coordinates
        time_lapse: Enable timelapse mode
        time_lapse_interval: Seconds between captures in timelapse mode
        time_lapse_duration: Total duration for timelapse in seconds
        data_folder: Folder to save images (uses current timestamped folder if None)
    """
    if data_folder is None:
        data_folder = data_directory()
    
    timestamp = datetime.now().strftime("%H_%M_%S")
    base_filename = f"camera{camera_id}_pos_{x}_{y}_{z}_{timestamp}"
    
    if not time_lapse:
        # Single capture
        filename = f"{base_filename}.jpg"
        
        try:
            success, result = capture_image(camera_id=camera_id, filename=filename, method='fswebcam')
            if success:
                print(f"✓ Captured image: {result}")
                return result
            else:
                print(f"✗ Capture failed: {result}")
                return None
        except Exception as e:
            print(f"✗ Error capturing image: {e}")
            return None
    else:
        # Timelapse capture
        print(f"Starting timelapse: {time_lapse_duration}s duration, {time_lapse_interval}s intervals")
        
        captured_files = []
        start_time = time.time()
        
        for i in range(0, time_lapse_duration, time_lapse_interval):
            elapsed = time.time() - start_time
            if elapsed >= time_lapse_duration:
                break
                
            frame_filename = f"{base_filename}_frame_{i//time_lapse_interval:04d}.jpg"
            
            try:
                success, result = capture_image(camera_id=camera_id, filename=frame_filename, method='fswebcam')
                if success:
                    captured_files.append(result)
                    print(f"✓ Frame {i//time_lapse_interval:04d}: {result}")
                else:
                    print(f"✗ Frame {i//time_lapse_interval:04d} failed: {result}")
                
                # Sleep for the interval (except for the last frame)
                if elapsed + time_lapse_interval < time_lapse_duration:
                    time.sleep(time_lapse_interval)
                    
            except Exception as e:
                print(f"✗ Error capturing frame {i//time_lapse_interval}: {e}")
        
        print(f"✓ Timelapse complete: {len(captured_files)} frames captured")
        return captured_files

def main():

    # Initialize controller (localhost since running on Pi)
    printer = KlipperController()
    printer.connect()
    
    # Initialize loadcell
    #initialize_loadcell()
    
    
    # Create data folder and initialize camera system
    data_folder = data_directory()


    initialize_camera_system(data_folder)
    cameras = list_cameras()


    print(f"Available cameras: {len(cameras)}")
    for camera in cameras:
        print(f"  - {camera['name']} ({camera['id']}) at {camera['node']}")
    
    # Configure camera focus settings
    print("Configuring camera focus settings...")
    camera_info = get_camera_info(1)  # Overhead Camera
    if camera_info:
        print(f"Overhead Camera: {camera_info['capture_resolution']} resolution")
    
    camera_info = get_camera_info(2)  # Side Camera  
    if camera_info:
        print(f"Side Camera: {camera_info['capture_resolution']} resolution")


    #Opening printer GUI
    
    def run_gui():
        root = tk.Tk()
        app = CameraGUI(root)
        root.mainloop()
    
    gui_thread = threading.Thread(target=run_gui, daemon=True)
    gui_thread.start()
    
    # Initialize printer and capacitor parameters
    print("Initializing printer and capacitor parameters...")
    
    # Select printer profile (choose one based on your needs)
    printer_profile = MXeneProfile_pet_25G  # Example: using PET 25G profile
    capacitor_profile = stdCap  # Example: using standard capacitor
    
    # Enable pressure-based extrusion if needed
    # printer_profile.constPressure(target_pressure=5.0)  # Uncomment and set target pressure
    
    print(f"Printer profile: {printer_profile}")
    print(f"Capacitor profile: {capacitor_profile}")
    print(f"Extrusion rate: {printer_profile.extrusion}")
    print(f"Feed rate: {printer_profile.feed_rate}")
    print(f"Print height: {printer_profile.print_height}")
    
    data_folder = data_directory()

    toolpath = generate_toolpath(prnt=printer_profile, cap=capacitor_profile)
    save_toolpath(toolpath, data_folder)

    data_collector = DataCollector()
    #data_collector.record_print_data(printer, getLoad)



    print("Ready to print.")
    print("Click 'Begin Print Sequence' in the GUI to start printing.")
    
    # Wait for the user to click the button in the GUI
    # We'll use a simple polling mechanism to check if the button was clicked
    global print_sequence_started
    print_sequence_started = False
    
    def check_button_click():
        global print_sequence_started
        if print_sequence_started:
            return True
        return False
    
    # Wait for button click (poll every 100ms)
    while not check_button_click():
        time.sleep(0.1)
    
    print("Print sequence initiated by user!")
    
    for comand in toolpath:
        if "CAPTURE" in comand:
            try:
                # Parse CAPTURE command: "CAPTURE, camera, x, y, z"
                parts = [part.strip() for part in comand.split(",")]
                if len(parts) != 5:
                    print(f"✗ Invalid CAPTURE format: {comand}")
                    continue
                    
                camera = int(parts[1])
                x = float(parts[2])
                y = float(parts[3])
                z = float(parts[4])

                print(f"Capturing image from camera {camera} at {x}, {y}, {z}")
                printer.send_gcode(absolute()[0])
                printer.send_gcode(movePrintHead(0, 0, z, printer_profile)[0])
                printer.send_gcode(movePrintHead(x, y, 0, printer_profile)[0])
                
                # Use the improved capture_live_print function
                result = capture_live_print(
                    camera_id=camera,
                    x=x, y=y, z=z,
                    time_lapse=False,  # Set to True for timelapse mode
                    data_folder=data_folder
                )
                
                if result:
                    print(f"✓ Capture completed: {result}")
                else:
                    print(f"✗ Capture failed")
                
                time.sleep(1)
                
            except (ValueError, IndexError) as e:
                print(f"✗ Error parsing CAPTURE command '{comand}': {e}")
                continue

        elif ";" not in comand:
            printer.send_gcode(comand)
            time.sleep(0.01)

    #data_collector.stop_record_data()
    
    # Optional: Capture final images from all cameras
    print("Capturing final images from all cameras...")
    from camera_integration import capture_all_cameras
    final_captures = capture_all_cameras(filename_prefix="final", method='fswebcam')
    
    for camera_id, (success, result) in final_captures.items():
        if success:
            print(f"✓ Final capture {camera_id}: {result}")
        else:
            print(f"✗ Final capture {camera_id} failed: {result}")
    
    print("Print sequence completed successfully!")

main()