import os
from datetime import datetime
import time
from tkinter import N
from g_code import absolute, movePrintHead, moveZ, primeRoutine
from hardware.klipper_controller import *


from hardware.camera_integration import (
    initialize_cameras, capture_image, capture_all_cameras,
    start_timelapse, stop_timelapse, cleanup_all,
    get_available_cameras, VIDEO_DEVICES
)


def data_directory(folder_name=None):
    """
    Create a timestamped directory within the data folder.
    Returns the folder name in format MonthMM_DD_HH_MM_SS
    """
    
    
    # Create data folder if it doesn't exist
    data_folder = "data"
    if not os.path.exists(data_folder):
        os.makedirs(data_folder)
    
    # Generate timestamp in the required format
    timestamp = datetime.now().strftime("%m_%d_%H_%M_%S")
    
    # Create the full path for the new directory
    if folder_name is None:
        new_dir_path = os.path.join(data_folder, timestamp)
    else:
        new_dir_path = os.path.join(data_folder, f"{folder_name}_{timestamp}")
    # Create the directory
    os.makedirs(new_dir_path, exist_ok=True)
    
    print(f"Created timestamped directory: {new_dir_path}")
    return new_dir_path

def save_toolpath(toolpath, data_folder):
        """
        Save the toolpath as a G-code file
        """
        # Generate timestamp for filename
        timestamp = datetime.now().strftime("%m_%d_%H_%M_%S")
        filename = f"toolpath_{timestamp}.gcode"
        filepath = os.path.join(data_folder, filename)
        
        try:
            with open(filepath, 'w') as f:
                # Write G-code header
                f.write("; Toolpath generated by MXene printer\n")
                f.write(f"; Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write("; Format: G1 X<x> Y<y> Z<z> E<extrusion>\n\n")
                
                # Write each toolpath point as G-code
                for cmd in (toolpath):
                   f.write(cmd+"\n")


                
                f.write("\n; End of toolpath\n")
            
            print(f"✓ Toolpath saved as G-code: {filepath}")
            return filepath
            
        except Exception as e:
            print(f"✗ Error saving toolpath: {e}")
            return None

 # change to time based capture           
def capture_live_print(comand, klipper_ctrl, prnt , file_path):

    """
    Args:
        camera_id: Camera ID to capture from
        x, y, z: Current position coordinates
        file_path: Directory to save images
        file_name: Base filename for the image(s)
        time_lapse: Enable timelapse mode
        time_lapse_interval: Seconds between captures in timelapse mode
        time_lapse_duration: Total duration for timelapse in seconds
    """
 
    os.makedirs(file_path, exist_ok=True)

    try:
        parts = [part.strip() for part in comand.split(",")]
        
        camera = int(parts[1])
        x = float(parts[2])
        y = float(parts[3])
        z = float(parts[4])
        file_name = parts[5]


    except (ValueError, IndexError) as e:
        print(f"✗ Error parsing CAPTURE command '{comand}': {e}")
        return None

    if file_name is None:
        file_name = f"capture_cam{camera}_x{x}_y{y}_z{z}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.jpg"
    else:
        file_name = f"{file_name}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.jpg"

    if 'True' in parts[6]:
        time_lapse = True
    else:
        time_lapse = False
    
    #Move to Capture Location


    klipper_ctrl.send_gcode(absolute()[0])
    klipper_ctrl.send_gcode(moveZ(z, prnt)[0])
    klipper_ctrl.send_gcode(movePrintHead(x, y, z, prnt)[0])
    
    #Wait for Printer to be in Position

    klipper_ctrl.wait_for_idle()
    print(f"Printer is in position: X={x}, Y={y}, Z={z}")
    klipper_ctrl.get_position()
    print(f"Printer is ready to capture")

   # input("Hit Enter When Printer Arrives at capture location:\n")

    if camera == 1:
        camera_id = "video0"
    elif camera == 2:
        camera_id = "video2"

    if not time_lapse:
        success, result = capture_image(camera_id, file_path, file_name)

        if success:
            print(f"✓ Image captured successfully: {result}")

            return result
        else:
            print(f"✗ Image capture failed: {result}")
            return None

            
    else:
        timelapse_prefix = file_name.replace('.jpg', '').replace('.jpeg', '')
        time_lapse_interval = int(parts[7])
        time_lapse_duration = int(parts[8])
        success = start_timelapse(
            device_id=camera_id,
            interval_seconds=time_lapse_interval,
            duration_seconds=time_lapse_duration,
            save_path=file_path,
            filename_prefix=timelapse_prefix
        )

        if success:
            print(f"✓ Timelapse started successfully")
            print(f"   Duration: {time_lapse_duration}s")
            print(f"   Interval: {time_lapse_interval}s")
            print(f"   Expected frames: {time_lapse_duration // time_lapse_interval}")
            return f"timelapse_started_{camera_id}_{timelapse_prefix}"
        else:
            print(f"✗ Failed to start timelapse")
            return None


def execute_toolpath(klipper_ctrl, printer, toolpath, data_folder):
    try:
        for comand in toolpath:
            
            if "CAPTURE" in comand:

                pos = klipper_ctrl.get_position() # = Tuple (x, Y, Z, E)
                
                pos_x = pos[0]
                pos_y = pos[1]
                pos_z = pos[2]

                capture_live_print(
                        comand=comand, 
                        klipper_ctrl=klipper_ctrl, 
                        prnt=printer, 
                        file_path=data_folder)
                

                #klipper_ctrl.send_gcode(movePrintHead(pos_x, pos_y, pos_z, printer)[0])

            elif "PASUE" in comand:

                try:
                    parts = [part.strip() for part in comand.split(",")]
                    delay = int(parts[1])
                    klipper_ctrl.wait_for_idle()
                    klipper_ctrl.get_printer_state()

                    time.sleep(delay)

                except (ValueError, IndexError) as e:
                    print(f"✗ Error parsing PASUE command '{comand}': {e}")
                    continue

            elif "WAIT" in comand:
                
                print("Waiting for user input to continue with print sequence\n")
                input("Hit Enter to Continue:\n")

            elif comand.startswith("PRINT_MESSAGE"):

                parts = [part.strip() for part in comand.split(",")]
                message = parts[1]
                print(f"Message in ToolPath: {message}")

            elif comand.strip() and not comand.strip().startswith(";"):
                
                klipper_ctrl.send_gcode(comand)
                klipper_ctrl.get_printer_state()
                time.sleep(0.01)  
        return True
        
    except (ValueError, IndexError) as e:
        print(f"✗ Print Sequence Failed: {e}")
        return False

def PrimePrinter(printer, klipper_ctrl):
    print(" Priming Printer ") 

    sucsess = False
    x_start = 5

    while not sucsess:
        # Execute the prime routine at the current x_start position
        execute_toolpath(primeRoutine(printer, x_start=x_start))        
        # Prompt the user to confirm if the priming was successful

        print("Was the priming successful? (y/n): ")
        
        try:
            response = input().strip().lower()
            if response == 'y':
                sucsess = True
                klipper_ctrl.send_gcode(PrimePrinter(printer, x_start=x_start)[0])
            elif response == 'n':
                # If not successful, increment x_start and try again
                x_start += 15
            else:
                print("Please enter 'y' for yes or 'n' for no.")
        except Exception as e:
            print(f"Error reading input: {e}")
            # Optionally, you could continue or break here depending on desired behavior
            continue

        return sucsess